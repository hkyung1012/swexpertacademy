"""
####################################################
[알고리즘 개요]
 본 영상은 '동적 계획법(Dynamic Programming, DP)'을 소개하고 이와 유사한 '분할 정복(Divide and Conquer)' 기법과 비교 설명합니다.

[동적 계획법의 핵심 원리]
1.  **부분 문제의 중복 및 저장 (Memoization/Tabulation)**: 분할 정복과 달리, 동적 계획법은 문제를 작은 부분 문제로 쪼갤 때 **중복되는 부분 문제**가 발생하는 경우에 효과적입니다.
2.  **테이블 재사용**: 작은 부분 문제들의 해답을 리스트나 배열 같은 **테이블에 미리 저장**해 둡니다.
3.  **효율성**: 큰 문제의 해답을 계산할 때, 이 테이블에 저장된 작은 문제의 해답을 **재사용**함으로써 중복 계산을 피하고 알고리즘의 실행 시간을 크게 단축합니다.

[주요 예시]
1.  **피보나치 수(Fibonacci Number)**:
    * 단순 재귀(분할 정복) 방식은 중복 호출이 발생하여 비효율적입니다(O(1.6ⁿ) 시간).
    * 동적 계획법(반복문/저장) 방식은 F(0)부터 순서대로 계산하여 저장해 재사용함으로써 **O(n)**의 선형 시간으로 해결할 수 있음을 보여줍니다.

2.  **계단 오르기 문제(Stair Climbing Problem)**: https://www.acmicpc.net/problem/2579
    * 한 번에 한 칸 또는 두 칸을 오를 수 있을 때 n층까지 오르는 경우의 수는 A(n) = A(n-1) + A(n-2)라는 **점화식**을 가집니다.
    * 이는 피보나치 수열과 동일한 형태의 점화식이며, 이처럼 점화식을 찾고 작은 값부터 순차적으로 계산해 저장하며 문제를 푸는 것이 동적 계획법의 전형적인 접근 방식입니다.
     N개의 계단을 오르는 경우의 수 DP[N]은 바로 이전 계단(N-1)에서 1칸을 오르는 경우와,
     그 이전 계단(N-2)에서 2칸을 오르는 경우의 합이므로, 점화식은 다음과 같습니다.
     DP[N] = DP[N-1] + DP[N-2]
###################################################
"""

